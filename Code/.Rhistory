Z <- rep(0, m)
Z <- replicate(m, (sqrt(n)*(mean(rexp(n, lambda))-(lambda)^(-1)))/(lambda)^(-1))
return(Z)
}
n <- c(5, 10, 100, 500, 1000, 10000)
i <- 1:6
Muestra <<- matrix(0L, 1000, 6)
Zn <- function(n, lambda, m) {
set.seed(0)
Z <- rep(0, m)
Z <- replicate(m, (sqrt(n)*(mean(rexp(n, lambda))-(lambda)^(-1)))/(lambda)^(-1))
return(Z)
}
n <- c(5, 10, 100, 500, 1000, 10000)
i <- 1:6
Muestra <<- matrix(0L, 1000, 6)
auxiliar <- sapply(i, function(i) hist(Muestra[, i] <<- Zn(n[i], 1, 1000), main = paste("St normal distribution n =", n[i]),
xlab = "Zn",  col ="darkviolet", border = "black") )
View(Muestra)
hist(Zn(5, 1, 1000),main = paste("St normal distribution m =", 1000),
xlab = "Zn",  col ="darkviolet", border = "black")
hist(Zn(10, 1, 1000),main = paste("St normal distribution m =", 1000),
xlab = "Zn",  col ="darkviolet", border = "black")
hist(Zn(100, 1, 1000), main = paste("St normal distribution m =", 1000),
xlab = "Zn",  col ="darkviolet", border = "black")
hist(Zn(500, 1, 1000), main = paste("St normal distribution m =", 1000),
xlab = "Zn",  col ="darkviolet", border = "black")
hist(Zn(1000, 1, 1000), main = paste("St normal distribution m =", 1000),
xlab = "Zn",  col ="darkviolet", border = "black")
hist(Zn(10000, 1, 1000), main = paste("St normal distribution m =", 1000),
xlab = "Zn",  col ="darkviolet", border = "black")
# Funcion para encontrar los qqplot.
qqplotFunction<-function(data, sizeSample){
sort(data)
n <- length(data)
x <- 1:length(data)
p <- x/(n+1)
teorico <-qnorm(c(0.25, 0.75))
estimado <- quantile(data, c(0.25, 0.75))
slope <- diff(estimado) / diff(teorico)
int <- estimado[1] - slope * teorico[1]
plot(qnorm(p), sort(data),  type = "p",
ylab = "Observaciones", xlab ="Zi",
main = paste("Normal QQ- plot   n =", sizeSample), pch=20)
abline(int, slope)
}
qqplotFunction(Muestra[ ,6], n[6])
i <- 1:6
auxiliar2 <- sapply(i, function(i) qqplotFunction(Muestra[ ,i], n[i]) )
#Sesgo a la derecha
par(mfrow=c(1,2))
qqplotFunction(Muestra[ ,1], n[1])
hist(Muestra[ ,1])
#Se aproxima a una normal
par(mfrow=c(1,2))
qqplotFunction(Muestra[ ,6], n[6])
hist(Muestra[ ,6])
pp_plotFunction<-function(data, sizeSample){
n <- length(data)
x <- 1:length(data)
pest <- x/(n+1)
teorico <-pnorm(c(0.25, 0.75))
estimado <- c(0.25, 0.75)
slope <- diff(estimado) / diff(teorico)
int <- estimado[1] - slope * teorico[1]
Fest <- pest
Fn <- pnorm(sort(data), mean(data), sd(data))
plot(Fest, Fn,  type = "p",
ylab = "Observaciones", xlab ="zi",
main = paste("Normal PP- plot n = ", sizeSample), pch=20)
}
pp_plotFunction(Muestra[ , 1], n[1])
i <- 1:6
auxiliar3 <- sapply(i, function(i) pp_plotFunction(Muestra[ ,i], n[i]) )
Zn2 <- function(n, p, N, m) {
set.seed(0)
Z <- rep(0, m)
Z <- replicate(m, (sqrt(n)*(mean(rbinom(n, size = N, prob = p))-(N*p))/(sqrt(N*p*(1-p)))))
return(Z)
}
#b) Para p = 1/2 y N = 15, repita los incisos 2b) y 2c) para el caso Binomial de este ejercicio.
n <- c(5, 10, 100, 500, 1000, 10000)
i <- 1:6
Muestra <<- matrix(0L, 1000, 6)
auxiliar <- sapply(i, function(i) hist(Muestra[, i] <<- Zn2(n[i], .5, 15,1000), main = paste("St normal distribution n =", n[i]),
xlab = "Zn",  col ="darkviolet", border = "black") )
qqplotFunction(Muestra[ ,6], n[6])
i <- 1:6
auxiliar2 <- sapply(i, function(i) qqplotFunction(Muestra[ ,i], n[i]) )
pp_plotFunction(Muestra[ , 1], n[1])
i <- 1:6
auxiliar3 <- sapply(i, function(i) pp_plotFunction(Muestra[ ,i], n[i]) )
n <- c(5, 10, 20, 100)
i <- 1:4
Muestra <- matrix(0L, 1000, 4)
auxiliar <- sapply(i, function(i) hist(Muestra[, i] <<- Zn2(n[i], 0.1, 15,1000), main = paste("St normal distribution n =", n[i]),
xlab = "Zn",  col ="darkviolet", border = "black") )
hist(Muestra[, 4])
n <- c(5, 10, 20, 100)
i <- 1:4
Muestra <- matrix(0L, 1000, 4)
auxiliar <- sapply(i, function(i) hist(Muestra[, i] <<- Zn2(n[i], 0.99, 15,1000), main = paste("St normal distribution n =", n[i]),
xlab = "Zn",  col ="darkviolet", border = "black") )
View(Muestra)
hist(Muestra[, 4])
library("Rlab"," ")
SnSimulation <-function() {
Sn <- rep(0, 1000)
i<- 1: 1000
sapply(i, function (i) {x<-rbern(1, 0.4); x2<-rbern(1, 0.4);
if (x ==1 && x2 ==1){
Sn[i] <<- 1 } else { Sn[i] <<- 0}})
return(apply(as.matrix(Sn), 2, sum))
}
#Con una probabilidad de 0.99, de una distribucion binomial los datos se cargan hacia la izquierda,
#igual que en los casos anteriores converge cuando ala normal estandar cuando n es muy grande.
y que opinas sobre la velocidad de convergencia ??
##########################################################################################################################################################
#4b) Simule una sucesion de n = 1000 v.a. como arriba y calcule S1000 para p = 0:4. Repita
#este proceso 100 veces y grafique la distribucion empirica de S1000 que se obtiene de la
#simulacion y empalmela con la distribucion asintotica teorica que obtuvo. Comente sus resultados.
library("Rlab")
SnSimulation <-function() {
Sn <- rep(0, 1000)
i<- 1: 1000
sapply(i, function (i) {x<-rbern(1, 0.4); x2<-rbern(1, 0.4);
if (x ==1 && x2 ==1){
Sn[i] <<- 1 } else { Sn[i] <<- 0}})
return(apply(as.matrix(Sn), 2, sum))
}
n<- 1000
p<- .4
mean2 <- n*(p^2)
sd2<-sqrt(n*((p*(1-p))*(p*(1-p))))
FnEmpirica<- replicate(100, SnSimulation())
hist(FnEmpirica, main = "Distribucion empirica S = 100",
xlab = "Sn",  col ="darkviolet", border = "black")
FnTeorica <- replicate(100,rnorm(1, mean2 , sd2))
hist(FnTeorica,  main = "Distribucion te?rica S = 100",
xlab = "Sn",  col ="darkviolet", border = "black")
library("ggplot2", " ")
# Pasando a formato data frame
geom1 <- data.frame(x = FnEmpirica, group="Empirica")
geom2 <- data.frame(x = FnTeorica, group="Teorica")
graf <- rbind(geom1, geom2)
# Histogramas de las tres simulaciones
ggplot(graf, aes(x, fill=group, colour=group)) +
geom_histogram(aes(y=..count..), breaks=seq(130,200,5), alpha=.5,
position="identity", lwd=0.2) +
ggtitle("Distribuci?n asint?tica Sn")
###############################
# parametros de la simulacion
###############################
# colores
tiempo1 <-Sys.time()
morado <- rgb(t(col2rgb('purple')/255), alpha= 0.001)
naranja <- rgb(t(col2rgb('orange')/255), alpha= 0.001)
chido <- rgb(t(col2rgb('#0089E0')/255), alpha=0.001)
color1 <- rgb(t(col2rgb('#FA00A4')/255), alpha=0.001)
color2 <- rgb(t(col2rgb('#27D6C2')/255), alpha=0.001)
color3 <- rgb(t(col2rgb('#442CBC')/255), alpha=0.001)
###############################
n <- 25000 #tamanio de muestra
p <- 50 #numero de covariables
repeticiones <- 1000 # numero de simulaciones por caso
media <- 0
set.seed(0)
parametros <- sample(1:100, p)
coeficientes <- rnorm(p, 0, 2) #coeficientes normales
################################
# Funciones
library(VGAM) #implementacion de la funcion rayleith
library(ggplot2)
library(reshape2)
###############################
construye.data.normal <- function(funcion, n, p, media, parametros)
{
# funcion para simular una muestra normal
# con v.a. iid media cero y varianza la unidad
# entradas
# funcion (expretion): nombre de la funcion de la cual se muestrea
# n (numeric): tamanio de la muestra
# p (numeric): numero de covariables
# parametos (numeric): vector de parametros, en nuestro caso solo simulamos v.a. de un solo parametro
# para distribuciones de mas de un parametro se deben de fijar los demas parametros
datos <- matrix( rep(0, n*p), ncol = p, nrow = n ) #inicializamos la matriz para guardar la muestra
for(i in 1:p)
{
datos[, i] <- rnorm(n, mean=media, sd=parametros[i])
}
datos <- scale(datos) #scalamos para media cero y varianza uno
datos <- as.data.frame(datos)
colnames(datos) <- paste0('X', 1:p)
return(datos)
}
install.packages("VGAM")
###############################
# parametros de la simulacion
###############################
# colores
tiempo1 <-Sys.time()
morado <- rgb(t(col2rgb('purple')/255), alpha= 0.001)
naranja <- rgb(t(col2rgb('orange')/255), alpha= 0.001)
chido <- rgb(t(col2rgb('#0089E0')/255), alpha=0.001)
color1 <- rgb(t(col2rgb('#FA00A4')/255), alpha=0.001)
color2 <- rgb(t(col2rgb('#27D6C2')/255), alpha=0.001)
color3 <- rgb(t(col2rgb('#442CBC')/255), alpha=0.001)
###############################
n <- 500000 #tamanio de muestra
p <- 90 #numero de covariables
repeticiones <- 1000 # numero de simulaciones por caso
media <- 0
set.seed(0)
parametros <- sample(1:100, p)
coeficientes <- rnorm(p, 0, 2) #coeficientes normales
################################
# Funciones
library(VGAM) #implementacion de la funcion rayleith
library(ggplot2)
library(reshape2)
###############################
construye.data.normal <- function(funcion, n, p, media, parametros)
{
# funcion para simular una muestra normal
# con v.a. iid media cero y varianza la unidad
# entradas
# funcion (expretion): nombre de la funcion de la cual se muestrea
# n (numeric): tamanio de la muestra
# p (numeric): numero de covariables
# parametos (numeric): vector de parametros, en nuestro caso solo simulamos v.a. de un solo parametro
# para distribuciones de mas de un parametro se deben de fijar los demas parametros
datos <- matrix( rep(0, n*p), ncol = p, nrow = n ) #inicializamos la matriz para guardar la muestra
for(i in 1:p)
{
datos[, i] <- rnorm(n, mean=media, sd=parametros[i])
}
datos <- scale(datos) #scalamos para media cero y varianza uno
datos <- as.data.frame(datos)
colnames(datos) <- paste0('X', 1:p)
return(datos)
}
#######
simulacion.unif <- function(data = muestra.normal, repeticiones = 1000)
{
# funcion para simular un numero de 'repeticiones' de ma.a. a varianza con la muestra
# generar sus valores propios y regrezarlos
# Entradas:
# data (data.frame) : La muestra de la cual se busca un valor apropiadod de 'k' vec. propios
# repeticiones (numeric) : nuemero de iteraciones
valores.proios <- matrix(rep(0, repeticiones*dim(data)[2] ), ncol=repeticiones, nrow = dim(data)[2])
rangos <- apply(muestra.normal, 2, range) #guardamos los rangos de las columnas
row.names(rangos) <- c('min', 'max')
for( i in 1:repeticiones)
{
m.temp <- matrix( rep(0, dim(data)[1]*dim(data)[2] ), ncol=dim(data)[2], nrow=dim(data)[1])
for(j in 1:p)
{
m.temp[, j] <- runif( n = dim(data)[1], min=rangos['min', j], max=rangos['max', j])
}
m.temp <- scale(m.temp) # estandarizamos la simulacion
m.temp <- cor(m.temp)
valores.proios[, i] <- eigen(m.temp)$values
}
valores.proios <- valores.proios
valores.proios <- as.data.frame(valores.proios)
names(valores.proios) <- paste0('Repeticion', 1:repeticiones)
valores.proios$id.val <- 1:p
return(valores.proios)
}
eigen.muestra <- function(muestra)
{
# funcion para obtener los valores propios muestrales
# muestra (data.frame) : muestra a analizar
m.temp <- cor(muestra)
a <- eigen(m.temp)$values
a <- data.frame(id.val = 1:dim(muestra)[2], value=a)
a$variable <- 'Muestral'
return(a)
}
###############################
muestra.normal <- construye.data.normal(funcion=norm.cero, n=n, p=p, parametros = parametros, media=media)
y.normal <- as.matrix(muestra.normal)%*%coeficientes
##############################
val.norm.unif <- simulacion.unif(data=muestra.normal, repeticiones = repeticiones)
a <- melt(val.norm.unif, id='id.val')
eigen.normal <- eigen.muestra(muestra.normal)
ggplot(a, aes(x=id.val, y=value, fill=variable)) +geom_line(color=I(chido)) + theme_minimal() +
xlab('Valor propio ordenado') + ylab('Estimacion del valor propio') +
ggtitle('Parallel analysis, N(0,1)') +
geom_line(data=eigen.normal, aes(x=id.val, y=value, color=I('red')))+
stat_function(fun= function(x) 1, col='purple')
################################
tiempo2 <-Sys.time()
tiempo2-tiempo1
# con 50, 25000, y 1000 repeticiones
###############################
# parametros de la simulacion
###############################
# colores
tiempo1 <- Sys.time()
morado <- rgb(t(col2rgb('purple')/255), alpha= 0.5)
naranja <- rgb(t(col2rgb('orange')/255), alpha= 0.5)
chido <- rgb(t(col2rgb('#0089E0')/255), alpha=0.5)
color1 <- rgb(t(col2rgb('#FA00A4')/255), alpha=0.5)
color2 <- rgb(t(col2rgb('#27D6C2')/255), alpha=0.5)
color3 <- rgb(t(col2rgb('#442CBC')/255), alpha=0.5)
rojo <- rgb(t(col2rgb('#A40C1D')/255), alpha=.5)
azul <- rgb(t(col2rgb('#0B68C2')/255), alpha=.5)
verde <- rgb(t(col2rgb('#4C8946')/255), alpha=.5)
################################
# Funciones
library(VGAM) #implementacion de la funcion rayleith
library(ggplot2)
library(reshape2)
95+15+60
60*4
240-170
70-15
library(nnet)
?nnet::coef.nnet
library(nnet)
# use half the iris data
ir <- rbind(iris3[,,1],iris3[,,2],iris3[,,3])
targets <- class.ind( c(rep("s", 50), rep("c", 50), rep("v", 50)) )
targets
samp <- c(sample(1:50,25), sample(51:100,25), sample(101:150,25))
ir1 <- nnet(ir[samp,], targets[samp,], size = 2, rang = 0.1,
decay = 5e-4, maxit = 200)
ir1
class(ir1)
test.cl <- function(true, pred) {
true <- max.col(true)
cres <- max.col(pred)
table(true, cres)
}
test.cl(targets[-samp,], predict(ir1, ir[-samp,]))
coef(ir1)
?coef(ir1)
str(ir1)
ir1$wts
coef(ir1)
?nnet
8.9**2
78.63106**.5
?step
local <- '~/Desktop/Ecobici/Data/'
lista <- dir(local)
lista
i <- lista[1]
data <- read.csv(file=i)
head(data, 15)
print(i)
print('\n')
print('\n)
}
```
install.packages("httr")
install.packages("hms")
library(httr)
acceso.api <- 'https://pubsbapi.smartbike.com/oauth/v2/token?client_id={1569_3q712quy66uc0g4cw8k48s4wks00wsk8sgog4ss40kk4sc8kc8}&clien
t_secret={5m12s2mn98w80w8ogsw4gc48gskggk8cwoo8s8c0s4s0sw8}&grant_type=client_credentials'
conex <- GET(acceso.api)
r <- GET("http://httpbin.org/get")
r
acceso.api <- 'http://pubsbapi.smartbike.com/oauth/v2/token?client_id={1569_3q712quy66uc0g4cw8k48s4wks00wsk8sgog4ss40kk4sc8kc8}&clien
t_secret={5m12s2mn98w80w8ogsw4gc48gskggk8cwoo8s8c0s4s0sw8}&grant_type=client_credentials'
conex <- GET(acceso.api)
r <- GET("https://httpbin.org/get")
r
library(httr)
acceso.api <- 'https://pubsbapi.smartbike.com/oauth/v2/token?client_id={1569_3q712quy66uc0g4cw8k48s4wks00wsk8sgog4ss40kk4sc8kc8}&clien
t_secret={ 5m12s2mn98w80w8ogsw4gc48gskggk8cwoo8s8c0s4s0sw8g0g}&grant_type=client_credentials'
token <- GET(acceso.api)
acceso.api <- 'https://pubsbapi.smartbike.com/oauth/v2/token?client_id={1569_3q712quy66uc0g4cw8k48s4wks00wsk8sgog4ss40kk4sc8kc8}&clien
t_secret={5m12s2mn98w80w8ogsw4gc48gskggk8cwoo8s8c0s4s0sw8g0g}&grant_type=client_credentials'
token <- GET(acceso.api)
acceso.api <- 'https://pubsbapi.samrtbike.com/oauth/v2/token?client_id={1569_3q712quy66uc0g4cw8k48s4wks00wsk8sgog4ss40kk4sc8kc8}&client_secret={5m12s2mn98w80w8ogsw4gc48gskggk8cwoo8s8c0s4s0sw8g0g}&grant_type=client_credentials'
token <- GET(acceso.api)
acceso.api <- 'https://pubsbapi.smartbike.com/oauth/v2/token?client_id={1569_3q712quy66uc0g4cw8k48s4wks00wsk8sgog4ss40kk4sc8kc8}&client_secret={5m12s2mn98w80w8ogsw4gc48gskggk8cwoo8s8c0s4s0sw8g0g}&grant_type=client_credentials'
token <- GET(acceso.api)
token
View(token)
token$request$auth_token
library(httr)
acceso.api <- 'https://pubsbapi.smartbike.com/oauth/v2/token?client_id={1569_3q712quy66uc0g4cw8k48s4wks00wsk8sgog4ss40kk4sc8kc8}&client_secret={5m12s2mn98w80w8ogsw4gc48gskggk8cwoo8s8c0s4s0sw8g0g}&grant_type=client_credentials'
token <- GET(acceso.api)
token
library(httr)
acceso.api <- 'https://pubsbapi.smartbike.com/oauth/v2/token?client_id={1569_3q712quy66uc0g4cw8k48s4wks00wsk8sgog4ss40kk4sc8kc8}&client_secret={5m12s2mn98w80w8ogsw4gc48gskggk8cwoo8s8c0s4s0sw8g0g}&grant_type=client_credentials'
token <- GET(acceso.api)
token
library(httr)
acceso.api <- 'https://pubsbapi.smartbike.com/oauth/v2/token?client_id={1569_3q712quy66uc0g4cw8k48s4wks00wsk8sgog4ss40kk4sc8kc8}&client_secret={5m12s2mn98w80w8ogsw4gc48gskggk8cwoo8s8c0s4s0sw8g0g}&grant_type=client_credentials'
token <- GET(acceso.api)
token
library(readr)
?read_csv
library(openxlsx)
setwd("~/Desktop/CD2EDUARDOFOO/Retina/Code")
dir()
files <- dir()
?read.xlsx
files <- dir()
files[1]
imagenes.nombres <- read.xlsx(files[1])
library(openxlsx)
setwd("~/Desktop/CD2EDUARDOFOO/Retina/Code")
library(readxl)
setwd("~/Desktop/CD2EDUARDOFOO/Retina/Code")
files <- dir()
library(readxl)
setwd("~/Desktop/CD2EDUARDOFOO/Retina/Code")
files <- dir()
imagenes.nombres <- read.xlsx(files[1])
imagenes.nombres <- readxl_example(files[1])
?readxl_example
imagenes.nombres <- readxl_example(path = files[1])
files[1]
library(readxl)
setwd("~/Desktop/CD2EDUARDOFOO/Retina/Code")
files <- dir()
files
imagenes.nombres <- read_excel(path = files[1])
View(imagenes.nombres)
length(files)
for(i in 2:length(files))
{
archivo <- read_excel(path = files[i])
imagenes.nombres <- rbind(archivo)
}
library(readxl)
setwd("~/Desktop/CD2EDUARDOFOO/Retina/Code")
files <- dir()
imagenes.nombres <- read_excel(path = files[1])
for(i in 2:length(files))
{
archivo <- read_excel(path = files[i])
imagenes.nombres <- rbind(imagenes.nombres, archivo)
}
View(imagenes.nombres)
library(dplyr)
names(imagenes.nombres)
imagenes.nombres %>% mutate( y = sum(`Retinopathy grade` + `Risk of macular edema`)  )
imagenes.nombres %>% mutate( y = sum(`Retinopathy grade` + `Risk of macular edema`)  ) -> imagenes.nombres
names(imagenes.nombres)
sapply(imagenes.nombres, class)
imagenes.nombres %>% summarise( y = sum(`Retinopathy grade` + `Risk of macular edema`)  ) -> imagenes.nombres
imagenes.nombres$y
names(imagenes.nombres)
library(readxl)
setwd("~/Desktop/CD2EDUARDOFOO/Retina/Code")
files <- dir()
imagenes.nombres <- read_excel(path = files[1])
for(i in 2:length(files))
{
archivo <- read_excel(path = files[i])
imagenes.nombres <- rbind(imagenes.nombres, archivo)
}
library(dplyr)
names(imagenes.nombres)
table(imagenes.nombres[, 3], imagenes.nombres[, 3])
imagenes.nombres[, 4]
class(imagenes.nombres) <- 'data.frame'
table(imagenes.nombres[, 3], imagenes.nombres[, 4])
table(imagenes.nombres[, 3])
table(imagenes.nombres[, 3]!=0)
table(imagenes.nombres[, 3]!=0)/dim(imagenes.nombres)[1]
table(imagenes.nombres[, 3]==0)/dim(imagenes.nombres)[1]
names(imagenes.nombres)
imagenes.nombres %>% group_by(`Image name`) %>% summarise( y = sum(`Retinopathy grade` + `Risk of macular edema`)  ) -> imagenes.nombres
class(imagenes.nombres) <- 'data.frame'
imagenes.nombres$y
library(readxl)
setwd("~/Desktop/CD2EDUARDOFOO/Retina/Code")
files <- dir()
imagenes.nombres <- read_excel(path = files[1])
for(i in 2:length(files))
{
archivo <- read_excel(path = files[i])
imagenes.nombres <- rbind(imagenes.nombres, archivo)
}
library(dplyr)
names(imagenes.nombres)
imagenes.nombres %>% group_by(`Image name`) %>% summarise( y = `Retinopathy grade` >0   ) -> imagenes.nombres
class(imagenes.nombres) <- 'data.frame'
table(imagenes.nombres$y==0)/dim(imagenes.nombres)[1]
table(imagenes.nombres$y)
imagenes.nombres$y
View(imagenes.nombres)
imagenes.nombres$y <- as.numeric(imagenes.nombres$y)
View(imagenes.nombres)
View(archivo)
library(readxl)
setwd("~/Desktop/CD2EDUARDOFOO/Retina/Code")
files <- dir()
imagenes.nombres <- read_excel(path = files[1])
for(i in 2:length(files))
{
archivo <- read_excel(path = files[i])
imagenes.nombres <- rbind(imagenes.nombres, archivo)
}
library(dplyr)
names(imagenes.nombres)
imagenes.nombres %>% group_by(`Image name`) %>% mutate( y = `Retinopathy grade` >0   ) -> imagenes.nombres
View(imagenes.nombres)
class(imagenes.nombres) <- 'data.frame'
imagenes.nombres$y <- as.numeric(imagenes.nombres$y)
table(imagenes.nombres$y)/dim(imagenes.nombres)[1]
View(imagenes.nombres)
write.csv(imagenes.nombres)
write.csv(imagenes.nombres, file='metadata.csv')
write.csv(imagenes.nombres, file='metadata.csv', row.names = FALSE)
